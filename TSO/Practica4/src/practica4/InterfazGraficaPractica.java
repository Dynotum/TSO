/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Charly Mau
 */
package practica4;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.RandomAccessFile;
import java.io.File;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.*;

public class InterfazGraficaPractica extends javax.swing.JFrame {

    boolean resultado = false, bandInherente = false;
    public boolean bandNoExiste = false, bandNoExisteD = false;
    public String bytesInh, bytedirecto, bytesImm, bytesExt, bytesRel, bytesIdx, bytesIdx1, bytesIdx2, bytesCorIndx2, bytesDIdx;
    public String bytesORG, bytesEQU, bytesDB, bytesDCB, bytesFCB, bytesDW, bytesDCW, bytesFDB, bytesFCC, bytesDS, bytesDSB, bytesRMB, bytesDSW, bytesRMW, bytesEND;
    public int inm8, inm16, ban;
    public String Guarda1, Guarda2;
    public static int bytesSumAux = 0, tipoMUNDIAL;
    public static int auxSum = 0, res = 0;
    public static String codoMUNDIAL = null, rutaMUNDIAL = "/home/dyno/1/CODLOC.txt";
    public static String operandoMUNDIAL = null, etiquetaMUNDIAL = null;
    boolean bandETIQUETA = false;
    
    public InterfazGraficaPractica() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane3 = new javax.swing.JScrollPane();
        txtAreaCargarTABOP = new javax.swing.JTextArea();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtAreaCargarArchivo = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtCODLOC = new javax.swing.JTextArea();
        btnCargarArchivo = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtAreaResultado = new javax.swing.JTextArea();
        btnMostrarArchivo = new javax.swing.JButton();
        btnCargarTABOP = new javax.swing.JButton();
        btnMostrarTABOP = new javax.swing.JButton();
        btnCargarCODLOC = new javax.swing.JButton();
        btnResultado = new javax.swing.JButton();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtTABSIM = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        btnMostrarTABSIM = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtAreaCargarTABOP.setColumns(20);
        txtAreaCargarTABOP.setRows(5);
        txtAreaCargarTABOP.setFocusable(false);
        txtAreaCargarTABOP.setRequestFocusEnabled(false);
        jScrollPane3.setViewportView(txtAreaCargarTABOP);

        txtAreaCargarArchivo.setColumns(20);
        txtAreaCargarArchivo.setRows(5);
        txtAreaCargarArchivo.setFocusable(false);
        txtAreaCargarArchivo.setRequestFocusEnabled(false);
        jScrollPane1.setViewportView(txtAreaCargarArchivo);

        txtCODLOC.setColumns(20);
        txtCODLOC.setRows(5);
        jScrollPane4.setViewportView(txtCODLOC);

        btnCargarArchivo.setText("Examinar");
        btnCargarArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCargarArchivoActionPerformed(evt);
            }
        });

        txtAreaResultado.setColumns(20);
        txtAreaResultado.setRows(5);
        txtAreaResultado.setFocusable(false);
        txtAreaResultado.setRequestFocusEnabled(false);
        jScrollPane2.setViewportView(txtAreaResultado);

        btnMostrarArchivo.setText("Mostrar");
        btnMostrarArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMostrarArchivoActionPerformed(evt);
            }
        });

        btnCargarTABOP.setText("Examinar");
        btnCargarTABOP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCargarTABOPActionPerformed(evt);
            }
        });

        btnMostrarTABOP.setText("Mostrar");
        btnMostrarTABOP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMostrarTABOPActionPerformed(evt);
            }
        });

        btnCargarCODLOC.setText("Ver CODLOC");
        btnCargarCODLOC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCargarCODLOCActionPerformed(evt);
            }
        });

        btnResultado.setText("Resultado");
        btnResultado.setEnabled(false);
        btnResultado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnResultadoActionPerformed(evt);
            }
        });

        txtTABSIM.setColumns(20);
        txtTABSIM.setRows(5);
        jScrollPane5.setViewportView(txtTABSIM);

        jLabel1.setText("TABOP");

        jLabel2.setText("Archivo");

        jLabel3.setText("Resultado");

        jLabel4.setText("CODLOC");

        jLabel5.setText("TABSIM");

        btnMostrarTABSIM.setText("Ver TABSIM");
        btnMostrarTABSIM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMostrarTABSIMActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(btnCargarCODLOC)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 402, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel1)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(16, 16, 16)
                                        .addComponent(btnCargarTABOP)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(btnMostrarTABOP, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(16, 16, 16)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel2)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(12, 12, 12)
                                        .addComponent(btnCargarArchivo)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(btnMostrarArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel5)
                    .addComponent(jLabel3)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(btnMostrarTABSIM)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 497, Short.MAX_VALUE)
                            .addComponent(btnResultado, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane5))))
                .addContainerGap(14, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 258, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addComponent(jScrollPane3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnCargarTABOP)
                    .addComponent(btnCargarArchivo)
                    .addComponent(btnResultado)
                    .addComponent(btnMostrarTABOP)
                    .addComponent(btnMostrarArchivo))
                .addGap(13, 13, 13)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE)
                    .addComponent(jScrollPane4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnCargarCODLOC)
                    .addComponent(btnMostrarTABSIM))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    static String test = "", test1 = "";

    private void btnCargarArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCargarArchivoActionPerformed

        JFileChooser filechooser = new JFileChooser();
        int opc = filechooser.showOpenDialog(this);
        if (opc == JFileChooser.APPROVE_OPTION) {
            txtAreaCargarArchivo.setText(filechooser.getSelectedFile().getPath());
            test = filechooser.getSelectedFile().getPath();
        }
    }//GEN-LAST:event_btnCargarArchivoActionPerformed

    private void btnMostrarArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMostrarArchivoActionPerformed
        try {
            //Tiene que crear el archivo sin preguntar
            String ruta = "/home/dyno/1/PruebaPrac3.txt";
            FileReader fr = new FileReader(txtAreaCargarArchivo.getText()); // cargar directo "/home/dyno/Documentos/P2ASM.txt"
            BufferedReader br = new BufferedReader(fr);   //txtAreaCargarArchivo.getText()

            // cargar boton  txtAreaCargarArchivo.getText()
            //"/home/dyno/PruebaPrac3.txt"
            try {
                String s = "";
                String finl = "";
                while ((s = br.readLine()) != null) {
                    finl += s + "\n";

                    this.btnResultado.setEnabled(true);
                    resultado = true;
                }
                this.txtAreaCargarArchivo.setText(finl);
            } catch (Exception er) {
            }

        } catch (Exception e) {
        }
    }//GEN-LAST:event_btnMostrarArchivoActionPerformed

    private void btnCargarTABOPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCargarTABOPActionPerformed

        JFileChooser filechooser = new JFileChooser();
        int opc = filechooser.showOpenDialog(this);
        if (opc == JFileChooser.APPROVE_OPTION) {
            txtAreaCargarTABOP.setText(filechooser.getSelectedFile().getPath());
            test1 = filechooser.getSelectedFile().getPath();
        }
    }//GEN-LAST:event_btnCargarTABOPActionPerformed

    private void btnMostrarTABOPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMostrarTABOPActionPerformed

        try {
            //  String ruta = "/home/dyno/1/TABOP.txt";

            FileReader fr = new FileReader(txtAreaCargarTABOP.getText());//para cargar con boton mostrar directo "/home/dyno/Documentos/TABOP.txt"
            BufferedReader br = new BufferedReader(fr);                 //para cargar con boton  txtAreaCargarTABOP.getText()

            try {
                String s = "";
                String finl = "";
                while ((s = br.readLine()) != null) {
                    finl += s + "\n";

                }
                this.txtAreaCargarTABOP.setText(finl);
            } catch (Exception er) {
            }

        } catch (Exception e) {
        }
    }//GEN-LAST:event_btnMostrarTABOPActionPerformed

    private void btnCargarCODLOCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCargarCODLOCActionPerformed
        // TODO add your handling code here:
        try {
            String ruta = "/home/dyno/1/CODLOC.txt";
            FileReader fr = new FileReader(ruta); // cargar directo "/home/dyno/Documentos/P2ASM.txt"
            BufferedReader br = new BufferedReader(fr);                     // cargar boton  txtAreaCargarArchivo.getText()
            //"/home/dyno/PruebaPrac3.txt"
            try {
                String s = "";
                String finl = "";
                while ((s = br.readLine()) != null) {
                    finl += s + "\n";

                    this.btnCargarCODLOC.setEnabled(true);
                    resultado = true;
                }
                this.txtCODLOC.setText(finl);
            } catch (Exception er) {
            }

        } catch (Exception er) {
        }
    }//GEN-LAST:event_btnCargarCODLOCActionPerformed

    private void btnResultadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnResultadoActionPerformed

        

        if (resultado) {
            
            CargarArchivo();
        }//"Aqui se carga el archivo"
    }//GEN-LAST:event_btnResultadoActionPerformed

    private void btnMostrarTABSIMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMostrarTABSIMActionPerformed
        // TODO add your handling code here:
        try {
            String ruta = "/home/dyno/1/TABSIM.txt";
            FileReader fr = new FileReader(ruta);
            BufferedReader br = new BufferedReader(fr);
            
            try {
                String s = "";
                String finl = "";
                while ((s = br.readLine()) != null) {
                    finl += s + "\n";

                    this.btnMostrarTABSIM.setEnabled(true);
                    resultado = true;
                }
                this.txtTABSIM.setText(finl);
            } catch (Exception er) {
            }

        } catch (Exception er) {
        }
    }//GEN-LAST:event_btnMostrarTABSIMActionPerformed

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(InterfazGraficaPractica.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(InterfazGraficaPractica.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(InterfazGraficaPractica.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(InterfazGraficaPractica.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new InterfazGraficaPractica().setVisible(true);
            }
        });
    }
    
    public static void CrearCODLOC(String bytesSum, String Ope){
        
        String hexa,hexa1;
    //    System.out.println("Entro a crear CODLOC"); 
        
        int caca, tipo = 0;
        
        File CODLOC = new File("/home/dyno/1/CODLOC.txt");
		BufferedWriter bw = null;
		bytesSumAux = Integer.parseInt(bytesSum);
                
		try{
                    if(CODLOC.exists()){
                        auxSum += bytesSumAux;
                        hexa = Integer.toString(auxSum);
                        
                        caca = Integer.parseInt(hexa, 16);
                        String hex = Integer.toHexString(caca);
                    
                        //Se escribe al final el archivo
                        bw = new BufferedWriter(new FileWriter(CODLOC,true));
                        bw.write("CODLOC\t"+hex+"\t"+etiquetaMUNDIAL+"\t"+codoMUNDIAL+"\t"+Ope+"\t"+bytesSum+"\n");
                    }else{/*bytesSumAux*/
                        if(CODLOC.createNewFile()){
                            auxSum += bytesSumAux;
                            
                            bw = new BufferedWriter(new FileWriter(CODLOC));
                            bw.write("DIR_INC\t"+Ope+"\t"+etiquetaMUNDIAL+"\t"+codoMUNDIAL+"\t"+Ope+"\t"+bytesSum+"\n");
                        }
                    }
                        
		bw.close();
		}catch(IOException er){

		}
                
                if(etiquetaMUNDIAL != null && etiquetaMUNDIAL != ""){
                        //AQUI ESTA EL ROYO
                    CrearTABSIM(codoMUNDIAL,etiquetaMUNDIAL,auxSum);
                        //AQUI MI DYNO OnO    
                }
                etiquetaMUNDIAL = null;
	}
    
    public static void CrearTABSIM(String Codop, String etiqueta, int direccion){
        //Crear archivo TABSIM.txt
        File TABSIM = new File("/home/dyno/1/TABSIM.txt");
        BufferedWriter bwr = null;
        String inicioTABSIM = "";
        System.out.println("Esta es otra etiqueta "+etiqueta);
        System.out.println("Y este se supone es un Codop "+Codop);
        System.out.println("Yyyyy este es la direccion hexa: "+direccion);
        
        String comp = "EQU";
        
        try{
            if((Codop.compareTo(comp)) == 0){
                inicioTABSIM = "EQU(ETIQUETA ABSOLUTA) ";
                if(TABSIM.exists()){
                    bwr = new BufferedWriter(new FileWriter(TABSIM,true));
                    bwr.write(inicioTABSIM+"\t"+etiquetaMUNDIAL+"\t"+direccion+"\t"+Codop+"\n");
                }else{
                    if(TABSIM.createNewFile()){
                        bwr = new BufferedWriter(new FileWriter(TABSIM));
                        bwr.write(inicioTABSIM+"\t"+etiquetaMUNDIAL+"\t"+direccion+"\t"+Codop+"\n");
                    }
                }
                
            }else if((Codop.compareTo(comp)) != 0){
                inicioTABSIM = "CODLOC(ETIQUETA RELATIVA)";
                if(TABSIM.exists()){
                    bwr = new BufferedWriter(new FileWriter(TABSIM,true));
                    bwr.write(inicioTABSIM+"\t"+etiquetaMUNDIAL+"\t"+direccion+"\t"+Codop+"\n");
                }else{
                    if(TABSIM.createNewFile()){
                        bwr = new BufferedWriter(new FileWriter(TABSIM));
                        bwr.write(inicioTABSIM+"\t"+etiquetaMUNDIAL+"\t"+direccion+"\t"+Codop+"\n");
                    }
                }
            }else{
                inicioTABSIM = "ESTO NO ES";
            }
            
            bwr.close();
        }catch(IOException er){
            
        }
    }
    
    public static void addDIRECTIVAS(String bytesSum, String Ope, int n){
        
        String hexa,hexa1;
        System.out.println("entro addDIRECTIVAS");
        
        int caca;
       
        File CODLOC = new File("/home/dyno/1/CODLOC.txt");
		BufferedWriter bw = null;
		bytesSumAux = Integer.parseInt(bytesSum);
                
		try{
                    if(CODLOC.exists()){
                        //Se escribe al final el archivo
                        if(n == 0){
                              auxSum += bytesSumAux;
                        }
                        else if(n == 1){
                            
                            auxSum += bytesSumAux;
                        }
                        else if(n == 2){
                            bytesSumAux = bytesSumAux * 2;
                            auxSum += bytesSumAux;
                        }
                        
                        String hex = Integer.toHexString(auxSum);
                        System.out.println("ENTRO HEX " + hex);
                            
                        bw = new BufferedWriter(new FileWriter(CODLOC,true));
                        bw.write("CODLOC\t"+hex+"\t"+etiquetaMUNDIAL+"\t"+codoMUNDIAL+"\t"+operandoMUNDIAL+"\t"+bytesSum+"\n");
                    }else{
                        if(CODLOC.createNewFile()){
                            if(n == 0){
                                auxSum += bytesSumAux;
                            }
                            if(n == 1){
                                auxSum += bytesSumAux;
                     
                                bytesSumAux += 1;
                            }
                            else if(n == 2){                        
                                bytesSumAux = bytesSumAux * 2;
                                auxSum += bytesSumAux;
                            }
                            
                            String hex = Integer.toHexString(auxSum);
                            System.out.println("ENTRO HEX " + hex);
                                
                            bw = new BufferedWriter(new FileWriter(CODLOC));
                            bw.write("DIR_INC\t"+hex+"\t"+etiquetaMUNDIAL+"\t"+codoMUNDIAL+"\t"+operandoMUNDIAL+"\t"+bytesSum+"\n");
                        }
                    }
                    
                    if(etiquetaMUNDIAL != null && etiquetaMUNDIAL != ""){
                        //AQUI ESTA EL ROYO
                    CrearTABSIM(codoMUNDIAL,etiquetaMUNDIAL,auxSum);
                        //AQUI MI DYNO OnO    
                    }
                    etiquetaMUNDIAL = null;
                
                    bw.close();
		}catch(IOException er){

		}
    }

    public static int TamanioEtiqueta(String token) {

        if (token.length() > 8) {
            return 0;
        }

        return 1;
    }

    public static int TamanioCod(String token) {

        Pattern p = Pattern.compile("(^[a-zA-Z][a-zA-Z]*[.]?[a-zA-Z]*)");
        Matcher m = p.matcher(token);

        Pattern firstp = Pattern.compile("^[a-zA-Z].*$");
        Matcher mfirst = firstp.matcher(token);

        Pattern seconp = Pattern.compile("(.*)([.]+)(.*)([.]+)(.*)");//[a-zA-Z]*[.]?[a-zA-Z]*"
        Matcher msecon = seconp.matcher(token);

        Pattern thrp = Pattern.compile("[a-zA-Z]*");
        Matcher mthr = seconp.matcher(token);

        Pattern finl = Pattern.compile("^[Ee][Nn][Dd]");
        Matcher fin = finl.matcher(token);

        if (token.length() > 5) {
            return 0;
        } else {

            if (m.matches()) {
                //cadena bien
                if (fin.matches()) {
                    return 3; // END

                }
            } else {
                if (!mfirst.matches()) { //primer caracter letra
                    return -1;
                } else if (msecon.matches()) {
                    return 2;//dos puntos
                } else if (!mthr.matches()) {
                    return 1;//caracter raro
                }
            }
        }
        return -2;
    }

    public static int expRegEtiq(String token) {

        Pattern p = Pattern.compile("(^[a-zA-Z]{1})([a-zA-Z0-9_]){0,7}");
        Matcher m = p.matcher(token);
        Pattern firstp = Pattern.compile("^[a-zA-Z].*$");
        Matcher mfirst = firstp.matcher(token);

        if (m.matches()) {
            //  System.out.println("SI");
        } else {
            // System.out.println("NO");
            if (mfirst.matches()) {
                return -1;
            } else {
                return 1;
            }
        }
        return 0;
    }

    public int b1, b2, b3, b4, b5, b6, b7, b8, b9, b10;
    public int c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15;
    public int aux1, aux2, rel8, rel16;
    public int aux11, aux22;
        
 
    public String ImprimirOperandos(String operando) {
        String s = "";
        String imprimirPtds = "";

        try {
            int TIPO, numero;
            String expresion;
            expresion = operando;
            if (!bandNoExiste) {
                imprimirPtds += s + "\t ** No se encuentra en el TABOP **\n";
            } else if ((null == operando && b1 == 1) || bandInherente) {

                if (!bandInherente) {
                    imprimirPtds += s + "\t ** Modo Inherente, " + bytesInh + " bytes **\n";
                    CrearCODLOC(bytesInh,operando);
                } else {
                    imprimirPtds += s + "\n\t**EL CODOP NO DEBE DE TENER OPERANDO**\n";
                }

            } else if (operando.startsWith("#") && b2 == 2) {
                if (!operando.matches("[#][%|$|@]*[0-9]*[a-fA-F]*")) {
                    imprimirPtds += s + "\t ** Los caracteres validos son #,%,$,@,*,0-9,a-f,A-F **\n";
                } else {

                    if (operando.startsWith("#$")) {
                        expresion = expresion.replace('#', '0');
                        expresion = expresion.replace('$', '0');
                        numero = Integer.valueOf(expresion, 16);

                        if (inm8 == 8) {
                            // System.out.println("Si entro");
                            if (numero >= 0 && numero <= 255) { //
                                imprimirPtds += s + "\t ** Inmediato de 8 bits, " + bytesImm + " bytes **\n";
				CrearCODLOC(bytesImm,operando);
                            } else if (numero >= 256) {
                                imprimirPtds += s + "\t ** Fuera de rango **\n";
                            }

                        } else if (inm16 == 16) {
                            if (numero <= 65535 && numero >= 0) {
                                imprimirPtds += s + "\t ** Inmediato de 16 bits, " + bytesImm + " bytes **\n";
				CrearCODLOC(bytesImm,operando);
                            } else if (numero > 65535 || numero < 0) {
                                imprimirPtds += s + "\t ** Fuera de rango **\n";
                            }

                        } else {
                            imprimirPtds += s + "\t ** La base decimal solo acepta numeros del 0-9 **\n";
                        }

                    } else if (operando.startsWith("#%")) {
                        if (operando.matches("[#][%]*[0-1]*")) {
                            expresion = expresion.replace('#', '0');
                            expresion = expresion.replace('%', '0');
                            numero = Integer.valueOf(expresion, 2);

                            if (inm8 == 8) {
                                // System.out.println("Si entro");
                                if (numero >= 0 && numero <= 255) { //
                                    imprimirPtds += s + "\t ** Inmediato de 8 bits, " + bytesImm + " bytes **\n";
                                    CrearCODLOC(bytesImm,operando);
                                } else if (numero >= 256) {
                                    imprimirPtds += s + "\t ** Fuera de rango **\n";
                                }

                            } else if (inm16 == 16) {
                                if (numero <= 65535 && numero >= 0) {
                                    imprimirPtds += s + "\t ** Inmediato de 16 bits, " + bytesImm + " bytes **\n";
                                    CrearCODLOC(bytesImm,operando);
                                } else if (numero > 65535 || numero < 0) {
                                    imprimirPtds += s + "\t ** Fuera de rango **\n";
                                }

                            } else {
                                imprimirPtds += s + "\t ** La base decimal solo acepta numeros del 0-9 **\n";
                            }

                        } else {
                            imprimirPtds += s + "\t ** La base binaria solo acepta numeros del 0-1 **\n";
                        }
                    }
                    if (operando.startsWith("#@")) {
                        if (operando.matches("[#][@]*[0-7]*")) {
                               expresion = expresion.replace('#', '0');
                            expresion = expresion.replace('@', '0');
                            numero = Integer.valueOf(expresion, 8);

                            if (inm8 == 8) {
                                // System.out.println("Si entro");
                                if (numero >= 0 && numero <= 255) { //
                                    imprimirPtds += s + "\t ** Inmediato de 8 bits, " + bytesImm + " bytes **\n";
                                    CrearCODLOC(bytesImm,operando);
                                } else if (numero >= 256) {
                                    imprimirPtds += s + "\t ** Fuera de rango **\n";
                                }

                            } else if (inm16 == 16) {
                                if (numero <= 65535 && numero >= 0) {
                                    imprimirPtds += s + "\t ** Inmediato de 16 bits, " + bytesImm + " bytes **\n";
                                    CrearCODLOC(bytesImm,operando);
                                } else if (numero > 65535 || numero < 0) {
                                    imprimirPtds += s + "\t ** Fuera de rango **\n";
                                }

                            } else {
                                imprimirPtds += s + "\t ** La base decimal solo acepta numeros del 0-9 **\n";
                            }
                        } else {
                            imprimirPtds += s + "\t ** La base octal solo acepta numeros del 0-7 **\n";
                        }
                    } else if (operando.matches("[#][0-9]{1}[0-9]*")) {
                        expresion = expresion.replace('#', '0');
                        numero = Integer.valueOf(expresion, 10);
                        System.out.println("Numero del INMEDIATO :" + numero);
                        System.out.println("INM8: " + inm8);
                        System.out.println("INM16 " + inm16);

                        if (inm8 == 8) {
                            // System.out.println("Si entro");
                            if (numero >= 0 && numero <= 255) { //
                                imprimirPtds += s + "\t ** Inmediato de 8 bits, " + bytesImm + " bytes **\n";
                                CrearCODLOC(bytesImm,operando);
                            } else if (numero >= 256) {
                                imprimirPtds += s + "\t ** Fuera de rango **\n";
                            }

                        } else if (inm16 == 16) {
                            if (numero <= 65535 && numero >= 0) {
                                imprimirPtds += s + "\t ** Inmediato de 16 bits, " + bytesImm + " bytes **\n";
                                CrearCODLOC(bytesImm,operando);
                            } else if (numero > 65535 || numero < 0) {
                                imprimirPtds += s + "\t ** Fuera de rango **\n";
                            }

                        } else {
                            imprimirPtds += s + "\t ** La base decimal solo acepta numeros del 0-9 **\n";
                        }
                    }
                }

            } else if ((operando.startsWith("$") || operando.startsWith("%") || operando.startsWith("@")) && (b3 == 3 || b4 == 4)) {
                if (!operando.matches("[%|$|@]*[0-9]*[a-fA-F]*")) {
                    imprimirPtds += s + "\t **Error por alguno de los siguientes caracteres %,$,@,*,0-9,a-f,A-F **\n";
                } else {
                    if (operando.startsWith("$")) {
                        expresion = expresion.replace('$', '0');
                        numero = Integer.valueOf(expresion, 16);
                        if (numero < 256) {
                            imprimirPtds += s + "\t ** Modo Directo, " + bytedirecto + " bytes **\n";
                            CrearCODLOC(bytedirecto,operando);
                        } //System.out.println("Bytes directo : "+bytedirecto);}
                        else if (numero > 255 && numero < 65536) {
                            imprimirPtds += s + "\t ** Modo Extendido, " + bytesExt + " bytes **\n";
                            CrearCODLOC(bytesExt,operando);
                        } else if (numero > 65535) {
                            imprimirPtds += s + "\t ** fuera de rango **\n";
                        } else {
                            imprimirPtds += s + "\t ** La base hexadecimal solo acepta numeros del 0-9 y a-f,A-F **\n";
                        }

                    } else if (operando.startsWith("%")) {
                        if (operando.matches("[%]*[0-1]*")) {
                            expresion = expresion.replace('%', '0');
                            numero = Integer.valueOf(expresion, 2);
                            if (numero < 256) {
                                imprimirPtds += s + "\t ** Modo Directo, " + bytedirecto + " bytes **\n";
                                CrearCODLOC(bytedirecto,operando);
                            } else if (numero > 255 && numero < 65536) {
                                imprimirPtds += s + "\t ** Modo Extendido, " + bytesExt + " bytes **\n";
                                CrearCODLOC(bytesExt,operando);
                            } else if (numero > 65535) {
                                imprimirPtds += s + "\t ** fuera de rango **\n";
                            }
                        } else {
                            imprimirPtds += s + "\t ** La base binaria solo acepta numeros del 0-1 **\n";
                        }
                    }
                    if (operando.startsWith("@")) {
                        if (operando.matches("[@]*[0-7]*")) {
                            expresion = expresion.replace('@', '0');
                            numero = Integer.valueOf(expresion, 8);
                            if (numero < 256) {
                                imprimirPtds += s + "\t ** Modo Directo, " + bytedirecto + " bytes **\n";
                                CrearCODLOC(bytedirecto,operando);
                            } else if (numero > 255 && numero < 65536) {
                                imprimirPtds += s + "\t ** Modo Extendido, " + bytesExt + " bytes **\n";
                                CrearCODLOC(bytesExt,operando);
                            } else if (numero > 65535) {
                                imprimirPtds += s + "\t ** fuera de rango **\n";
                            }
                        } else {
                            imprimirPtds += s + "\t ** La base octal solo acepta numeros del 0-7 **\n";
                        }
                    }
                }
            } else if ((operando.toUpperCase().startsWith("A") || operando.toUpperCase().startsWith("B") || operando.toUpperCase().startsWith("D")) && b6 == 6) {

                if (expresion.trim().matches("(A|a]{1}|[B|b]{1}|[D|d]{1})[,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})")) {
                    imprimirPtds += s + "\t ** Modo Indizado de Acumulador, " + bytesIdx + " bytes **\n";
                } else {
                    imprimirPtds += s + "\t ** Error: La sintaxis correcta es [ A|a || B|b || D|d , reg ] reg:X,y,sp,pc **\n";
                }

            } else if (operando.startsWith("[") && b9 == 9) {
                expresion = expresion.replace('[', ' ');
                if (operando.endsWith("]")) {
                    expresion = expresion.replace(']', ' ');
                    ////////////

                     if (expresion.trim().matches("[,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})")){
                                imprimirPtds += s + "\t ** Modo Indizado Indirecto de 16 bitssss, (IDX), " + bytesCorIndx2 + " bytes **\n";
                                CrearCODLOC(bytesCorIndx2,operando);
                            }

                     else if (expresion.trim().matches("[a-zA-Z]*[,]*[A-Za-z]*") && (b10 == 10)) {
                        if (expresion.trim().matches("[D|d][,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})")) {                   //"(A|a]{1}|[B|b]{1}|[[D|d]{1})[,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})"
                            imprimirPtds += s + "\t ** Modo Indizado Indirecto de Acumulador, " + bytesDIdx + " bytes **\n";
                            CrearCODLOC(bytesDIdx,operando);
                        } else {
                            imprimirPtds += s + "\t ** Error: La sintaxis correcta es [D|d,reg] reg:X,y,sp,pc **\n";
                        }
                    } else {
                         if(expresion.trim().endsWith(","))
                            imprimirPtds += s + "\t ** la sintaxis correcta es [0-65535,SP,PC,X,Y] " + "**\n";
                         else{
                        StringTokenizer caracteres = new StringTokenizer(expresion, ",");
                        expresion = caracteres.nextToken();
                        numero = Integer.valueOf(expresion.trim(), 10);
                        expresion = caracteres.nextToken();
                        if (numero < 65536 && numero > -1) {
                            if (expresion.trim().equalsIgnoreCase("PC") || expresion.trim().equalsIgnoreCase("SP")
                                    || expresion.trim().equalsIgnoreCase("X") || expresion.trim().equalsIgnoreCase("Y")) {
                                imprimirPtds += s + "\t ** Modo Indizado Indirecto de 16 bits, (IDX), " + bytesCorIndx2 + " bytes **\n";
                                CrearCODLOC(bytesCorIndx2,operando);
                            } else {
                                imprimirPtds += s + "\t ** la sintaxis correcta es [0-65535,SP,PC,X,Y] " + "**\n";
                            }
                        }
                        else {
                            imprimirPtds += s + "\t ** Fuera de Rango **\n";
                        }}
                    }

                } else {
                    imprimirPtds += s + "\t ** FALTA CARACTER ] **\n";
                }
            } else if (operando.startsWith(",")) {
                if (operando.matches("[,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})")) {
                    imprimirPtds += s + "\t ** Modo Indizado de 5 bits, (IDX), " + bytesIdx + " bytes **\n";
                    CrearCODLOC(bytesIdx,operando);
                } else {
                    imprimirPtds += s + "\t ** Error despues de la \",\" **\n";
                }

            } else if (operando.matches("[-]*[0-9]*[,][a-zA-Z]*")) {
                StringTokenizer caracteres = new StringTokenizer(expresion, ",");
                expresion = caracteres.nextToken();
                numero = Integer.valueOf(expresion, 10);
                if (operando.matches("[-]*[0-9]*[,]([X|x|Y|y]{1}|[s|S][p|P]{1}|[p|P][c|C]{1})")) {
                    if (numero > -17 && numero < 16 && b6 == 6) {
                        imprimirPtds += s + "\t ** Modo Indizado de 5 bits, (IDX), " + bytesIdx + " bytes **\n";
                        CrearCODLOC(bytesIdx,operando);
                    } else if (numero > -257 && numero < 256 && b7 == 7) {
                        imprimirPtds += s + "\t ** Modo Indizado de 9 bits, (IDX1), " + bytesIdx1 + " bytes **\n";
                        CrearCODLOC(bytesIdx1,operando);
                    } else if (numero > 255 && numero < 65536 && b8 == 8) {
                        imprimirPtds += s + "\t ** Modo Indizado de 16 bits, (IDX2), " + bytesIdx2 + " bytes **\n";
                        CrearCODLOC(bytesIdx2,operando);
                    }
                } else {
                    imprimirPtds += s + "\t ** Nombre de registro invalido **\n";
                }
            } else if (operando.matches("[1-8]{1}[,][-|+]*([X|x|Y|y]{1}|[s|S][p|P]{1})[-|+]*") && b6 == 6) {
                StringTokenizer caracteres = new StringTokenizer(expresion, ",");
                expresion = caracteres.nextToken();
                numero = Integer.valueOf(expresion, 10);
                expresion = caracteres.nextToken();
                if (numero > 0 && numero < 9) {
                    if (operando.endsWith("-")) {
                        imprimirPtds += s + "\t ** Modo Indizado de Post Decremento, (IDX), " + bytesIdx + " bytes **\n";
                        CrearCODLOC(bytesIdx,operando);
                    } else if (operando.endsWith("+")) {
                        imprimirPtds += s + "\t ** Modo Indizado de Post Incremento, (IDX), " + bytesIdx + " bytes **\n";
                        CrearCODLOC(bytesIdx,operando);
                    } else if (expresion.startsWith("-")) {
                        imprimirPtds += s + "\t ** Modo Indizado de Pre Decremento, (IDX), " + bytesIdx + " bytes **\n";
                        CrearCODLOC(bytesIdx,operando);
                    } else if (expresion.startsWith("+")) {
                        imprimirPtds += s + "\t ** Modo Indizado de Pre Incremento, (IDX), " + bytesIdx + " bytes **\n";
                        CrearCODLOC(bytesIdx,operando);
                    } else {
                        imprimirPtds += s + "\t ** la sintaxis es valor, reg=X,Y,SP **\n";
                    }
                }
            } else if (b5 == 5) {
                if (operando.matches("(^[a-zA-Z]{1})([a-zA-Z0-9_]){0,7}")) {

                    if ("2".equals(bytesRel))//rel8==2
                    {
                        imprimirPtds += s + "\t ** Modo Relativo de 8 bits, " + bytesRel + " bytes **\n";
                        CrearCODLOC(bytesRel,operando);
                    } else if ("4".equals(bytesRel))//rel16==4
                    {
                        imprimirPtds += s + "\t ** Modo Relativo de 16 bits, " + bytesRel + " bytes **\n";
                        CrearCODLOC(bytesRel,operando);
                    }
                } else {
                    imprimirPtds += s + "\t ** No contiene el formato adecuado para una Etiqueta **\n";
                }

            } else if (operando.matches("(^[a-zA-Z]{1})([a-zA-Z0-9_]){0,7}") && (b4 == 4)) {

                if (b4 == 4 && b5 != 5) {
                    imprimirPtds += s + "\t ** Modo Extendido, " + bytesExt + " bytes **\n";
                    CrearCODLOC(bytesExt,operando);
                }

            }else if (operando.matches("[0-9]{1}([0-9])*") && (b3 == 3 || b4 == 4)) {
                numero = Integer.valueOf(expresion, 10);
                if (numero < 0) {
                    imprimirPtds += s + "\t ** fuera de rango **\n";
                } else {
                    if (numero < 256 && b3 == 3) {
                        imprimirPtds += s + "\t ** Modo Directo, " + bytedirecto + " bytes **\n";
			CrearCODLOC(bytedirecto,operando);
                    } else if (numero > 255 && numero < 65536 && b4 == 4) {
                        imprimirPtds += s + "\t ** Modo Extendido, " + bytesExt + " bytes **\n";
			CrearCODLOC(bytedirecto,operando);
                    } else if (numero > 65535) {
                        imprimirPtds += s + "\t ** fuera de rango **\n";
                    } else {
                        imprimirPtds += s + "\t ** fuera de rango **\n";
                    }

                }
            }else if (null == operando) {
                imprimirPtds += s + "\t ** Modo Inherente **\n";

            }
            else {
                imprimirPtds += s + "\t ** Operando invalido para este direccionamiento **\n";
            }
           cargarDIRECTIVAS(codoMUNDIAL, operando);

        } catch (Exception e) {
        }

        return imprimirPtds;
    }
    
    public String cargarDIRECTIVAS(String restante, String operandoTemp){
        System.out.println("entro cargarDRIRECT");
        System.out.println("ESTA ES UNA ETIQUETA "+etiquetaMUNDIAL);
        String s = "";
        String imprimirDIRECTIVA = "";
        int otroAux = 0;
        try {

            RandomAccessFile abrirDIRECTIVA = new RandomAccessFile("/home/dyno/1/DIRECTIVAS.txt", "r"); //Direccion archivo DIRECTIVA.txt
            // test1
            while (abrirDIRECTIVA.getFilePointer() != abrirDIRECTIVA.length()) {
                String renglon = abrirDIRECTIVA.readLine();

                StringTokenizer x = new StringTokenizer(renglon, "|"); //  elimina "|" or

                String codop = x.nextToken();
                String operando = x.nextToken();
                String TotalByte = x.nextToken();

                if (restante.toUpperCase().equals(codop)) {
                    if (operandoTemp == null && "SI".toUpperCase().equals(operando)) {
                        imprimirDIRECTIVA += s + "\n**EL CODOP  DEBE DE TENER OPERANDO**\n";
                    }

                    aux11 = 1;
                    if (operando.toUpperCase().equals("SI")) {
                        //operando="SI";
                        aux2 = 1;
                    } else if (operando.toUpperCase().equals("NO")) {
                        //operando="NO";
                        aux2 = 0;
                    }
                    
                    switch(codop) {
                        case "ORG":
                            otroAux = 0;
                            bytesORG = "0";
                            addDIRECTIVAS(bytesORG,bytesORG,otroAux);
                            break;
                        case "EQU":
                            otroAux = 0;
                            bytesEQU = "0";
                            addDIRECTIVAS(bytesEQU,bytesEQU,otroAux);
                            break;
                        case "DB":
                            otroAux = 0;
                            bytesDB = "1";                            
                            addDIRECTIVAS(bytesDB,bytesDB,otroAux);
                            break;
                        case "DC.B":
                            otroAux = 0;
                            bytesDCB = "1";
                            addDIRECTIVAS(bytesDCB,bytesDCB,otroAux);
                            break;
                        case "FCB":
                            otroAux = 0;
                            bytesFCB = "1";
                            addDIRECTIVAS(bytesFCB,bytesFCB,otroAux);
                            break;
                        case "DW":
                            otroAux = 0;
                            bytesDW = "2";
                            addDIRECTIVAS(bytesDW,bytesDW,otroAux);
                            break;
                        case "DC.W":
                            otroAux = 0;
                            bytesDCW = "2";
                            addDIRECTIVAS(bytesDCW,bytesDCW,otroAux);
                            break;
                        case "FDB":
                            otroAux = 0;
                            bytesFDB = "2";
                            addDIRECTIVAS(bytesFDB,bytesFDB,otroAux);
                            break;
                        case "FCC":
                            otroAux = 0;
                            bytesFCC = "1";
                            addDIRECTIVAS(bytesFCC,bytesFCC,otroAux);
                            break;
                        case "DS":
                            otroAux = 1;
                            bytesDS = TotalByte;
                            addDIRECTIVAS(operandoMUNDIAL,bytesDS,otroAux);
                            break;
                        case "DS.B":
                            otroAux = 1;
                            bytesDSB = TotalByte;
                            addDIRECTIVAS(operandoMUNDIAL,bytesDSB,otroAux);
                            break;
                        case "RMB":
                            otroAux = 1;
                            bytesRMB = TotalByte;
                            addDIRECTIVAS(operandoMUNDIAL,bytesRMB,otroAux);
                            break;
                        case "DS.W":
                            otroAux = 2;
                            bytesDSW = TotalByte;
                            addDIRECTIVAS(operandoMUNDIAL,bytesDSW,otroAux);
                            break;
                        case "RMW":
                            otroAux = 2;
                            bytesRMW = TotalByte;
                            addDIRECTIVAS(operandoMUNDIAL,bytesRMW,otroAux);
                            break;
                        case "END":
                            otroAux = 0;
                            bytesEND = "0";
                            addDIRECTIVAS(bytesEND,bytesEND,otroAux);
                            break;

                    }
                    bandNoExisteD = true;
                }
            }
            if (!bandNoExisteD) {
                imprimirDIRECTIVA += s + "\tNO SE ENCONTRO EL CODOP DE OPERACIÓN\n\n";
                
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return imprimirDIRECTIVA;
    }

    public String CargarTABOP(String restante, String operandoTemporal) {
        String s = "";
        String imprimirTABOP = "";

        bandInherente = false;
        try {

            RandomAccessFile abrirTABOP = new RandomAccessFile("/home/dyno/1/TABOP.txt", "r"); //"/home/dyno/Documentos/TABOP.txt"
            // test1
            while (abrirTABOP.getFilePointer() != abrirTABOP.length()) {
                String renglon = abrirTABOP.readLine();

                StringTokenizer x = new StringTokenizer(renglon, "|"); //  elimina "|" or

                String codop = x.nextToken();
                String operando = x.nextToken();
                String ModoDirec = x.nextToken();
                StringTokenizer y = new StringTokenizer(x.nextToken(), " "); //aqui tomo el token del codigo maquina, y lo separo solo imprimir hexa
                String codMaquina = y.nextToken();
                String calculadosByte = x.nextToken();
                String calcularByte = x.nextToken();
                String TotalByte = x.nextToken();

                if (restante.toUpperCase().equals(codop)) {
                    
                    if (operandoTemporal == null && "SI".toUpperCase().equals(operando)) {
                        imprimirTABOP += s + "\n**EL CODOP  DEBE DE TENER OPERANDO**\n";
                        
                    } else if (operandoTemporal != null && "NO".toUpperCase().equals(operando)) {
                        bandInherente = true;
                    }

                    aux1 = 1;
                    if (operando.toUpperCase().equals("SI")) {
                        //operando="SI";
                        aux2 = 1;
                    } else if (operando.toUpperCase().equals("NO")) {
                        //operando="NO";
                        aux2 = 0;
                    }
                    switch (ModoDirec) {
                        case "INH":
                            b1 = 1;
                            ModoDirec = "Inherente\t\t\t\t\t\t";
                            bytesInh = TotalByte;
                            break;
                        case "IMM":
                            b2 = 2;
                            bytesImm = TotalByte;
                            ModoDirec = "Inmediato\t\t\t\t\t\t";
                            System.out.println("este es inmediato el calcular " + calcularByte + "\n");
                            if (calcularByte.equals("2")) {
                                inm16 = 16;
                                inm8 = 0;
                            } else if (calcularByte.equals("1")) {
                                inm8 = 8;
                                inm16 = 0;
                            }
                            break;
                        case "DIR":
                            b3 = 3;
                            bytedirecto = TotalByte;
                            // System.out.print("Esto es TotalByte en Directo: " + TotalByte + "\nY esto es el bytesAll: " + bytesAll + "\n\n");
                            ModoDirec = "Directo\t\t\t\t\t\t";
                            break;
                        case "EXT":
                            b4 = 4;
                            bytesExt = TotalByte;
                            ModoDirec = "Extendido\t\t\t\t\t\t";
                            break;
                        case "REL":
                            b5 = 5;
                            bytesRel = TotalByte;
                            ModoDirec = "Relativo\t\t\t\t\t\t";
                            if (bytesRel.equals("4")) {
                                rel16 = 4;
                                System.out.println(bytesRel + " " + rel16);
                            } else {
                                rel8 = 2;
                                System.out.println(bytesRel + " " + rel8);
                            }
                            break;
                        case "IDX":
                            b6 = 6;
                            bytesIdx = TotalByte;
                            ModoDirec = "Indizado\t\t\t\t\t\t";
                            break;
                        case "IDX1":
                            b7 = 7;
                            bytesIdx1 = TotalByte;
                            ModoDirec = "Indizado de 9 bits\t\t\t";
                            break;
                        case "IDX2":
                            b8 = 8;
                            bytesIdx2 = TotalByte;
                            ModoDirec = "Indizado de 16 bits\t\t\t";
                            break;
                        case "[IDX2]":
                            b9 = 9;
                            bytesCorIndx2 = TotalByte;
                            ModoDirec = "Indizado indirecto de 16 bits\t";
                            break;
                        case "[D,IDX]":
                            b10 = 10;
                            bytesDIdx = TotalByte;
                            ModoDirec = "Indizado Indirecto de Acumulador";
                            break;

                    }
                    imprimirTABOP += s + "\t************************************";
                    imprimirTABOP += s + "\n\t MODO DIRECCIONAMIENTO:    " + ModoDirec;
                    imprimirTABOP += s + "\n\t OPERANDO:\t                        " + operando;
                    imprimirTABOP += s + "\n\t CODIGO MAQUINA:                 " + codMaquina;
                    imprimirTABOP += s + "\n\t B. CALCULADOS:                    " + calculadosByte;
                    imprimirTABOP += s + "\n\t B. POR CALCULAR:                 " + calcularByte;
                    imprimirTABOP += s + "\n\t SUMA TOTAL DE B.:               " + TotalByte + "\n";
                    imprimirTABOP += s + "\t************************************\n";
//BORRADOR
                    
                    

                    //aqui tengo que guardar el modo de direc y mandarlo a una funcion
                    // despues que imprima el modo de dic y la suma de bytes calculados
                   /* String direc = Direccionamiento(operandoTemporal, ModoDirec, TotalByte);

                     imprimirTABOP += s + direc;*/
                    imprimirTABOP += s + "\n";
                    bandNoExiste = true;
                }
            }
            if (!bandNoExiste) {
                
                imprimirTABOP = "\tNO SE ENCONTRO EL CODOP DE OPERACIÓN\n\n";
            }

            // this.txtAreaResultado.setText(finl);
        } catch (Exception e) {
            e.printStackTrace();
        }

        //System.out.println("Imprimir TABOP : " + imprimirTABOP);
        
        return imprimirTABOP;
    }

    public void CargarArchivo() {
        String operando = null, codop = null, eti = null;
        boolean banEnd = true;
        try {
            String s = "";
            String finl = "";

            RandomAccessFile openArchivo = new RandomAccessFile(test, "r"); // test   "/home/dyno/PruebaPrac3.txt"   tronadorPrac3_2
            //"/home/dyno/Documentos/P2ASM.txt"
            while (openArchivo.getFilePointer() != openArchivo.length() && banEnd) { //
                String renglon = openArchivo.readLine();

                StringTokenizer x = new StringTokenizer(renglon, " \t"); //espacio y tabulador los elimina

                if (x.hasMoreTokens()) {
                    if (renglon.charAt(0) == ';') {//SI EL PRIMER CARACTER ES ; TODO ES COMENTARIO
                        finl += s + "COMENTARIO\n\n";
                        // this.txtAreaResultado.append("COMENTARIO\n");

                    } else if (x.countTokens() == 1 && !Character.isWhitespace(renglon.charAt(0))) { //SINO, DEBE HABER 1 TOKEN Y EL PRIMER CARACTER SEA DIRENTE A UN ESPACIO
                        finl += s + "ETIQUETA: " + x.nextToken() + "\n";
                        
                        if (codop == null) {
                            finl += s + "CODOP: " + codop + "\n";
                            finl += s + "\tError: siempre debe de haber un código de operación" + "\n";
                            //String auxCodop = codop;
                        }
                        finl += s + "OPERANDO: " + operando + "\n";

                    } else {
                        String restante;
                        restante = x.nextToken();
                        
                        if (!Character.isWhitespace(renglon.charAt(0))) {

                            if (TamanioEtiqueta(restante) == 0) {
                                finl += s + "ETIQUETA: " + restante + "\n";
                                finl += s + "\tError: la longitud máxima de una etiqueta es de ocho caracteres." + "\n";
                            } else {
                                finl += s + "ETIQUETA: " + restante + "\n";
                                etiquetaMUNDIAL = restante;
                                if (expRegEtiq(restante) == 1) {
                                    finl += s + "\tError: la etiqueta debe de iniciar con letra" + "\n";
                                } else if (expRegEtiq(restante) == -1) {
                                    finl += s + "\tError: los caracteres válidos en las etiquetas son letras, dígitos (0..9) y el guión bajo" + "\n";

                                }
                            }

                            restante = x.nextToken();
                        } else {
                            if (eti == null) {
                                finl += s + "ETIQUETA: " + eti + "\n";
                            }
                            
                            

                        }
                        //aqui todo de codop
                        //String end = restante;
                        codoMUNDIAL = restante;
                        System.out.println("codopppppppppppp mundial: " + codoMUNDIAL +" Y " + restante);
                        finl += s + "CODOP:  " + restante + "\n";

                        /*
                         AQUI TENEMOS QUE MANDAR FUNCION, PARA VERIFICAR EL CODOP
                         */
                        
                        
                        if (TamanioCod(restante) == 0) {
                            finl += s + "\tError: la longitud máxima de un código de operación es de 5 caracteres." + "\n";
                        } else if (TamanioCod(restante) == -1) {
                            finl += s + "\tError: los códigos de operación deben de iniciar con letra." + "\n";
                        } else if (TamanioCod(restante) == 1) {
                            finl += s + "\tError: los caracteres válidos de los códigos de operación son letra y el carácter del punto" + "\n";
                        } else if (TamanioCod(restante) == 2) {
                            finl += s + "\tError: los códigos de operación no pueden tener más de un punto" + "\n";
                        } else if (TamanioCod(restante) == 3) {
                            finl += s + "OPERANDO: " + operando + "\n";
                            banEnd = false;
                            break;
                        }

                        if (x.hasMoreTokens()) {
                            finl += s + "OPERANDO: ";
                            //       restante = "";    //ask
                            while (x.hasMoreTokens()) {
                                //  restante = restante  + x.nextToken() + " ";
                                if (x.countTokens() > 1) {
                                    operando = x.nextToken();
                                    finl += s + operando + " ";
                                } else {
                                    operando = x.nextToken();
                                    finl += s + operando + " ";
                                }
                            }

                            finl += s + " \n";

                        } else {
                            finl += s + "OPERANDO: " + operando + "\n";
                        }
                        operandoMUNDIAL = operando;
                        finl += s + " \n";

                        String imprimirTABOP = CargarTABOP(restante, operando); //llamo funcion para TABOP
                        finl += s + imprimirTABOP;
                        

                        // checarOperando(operando);
                        if (bandNoExiste == true) {
                            finl += s + "\n=========[ Direccionamiento acuerdo al OPERANDO : " + operando + " ]=========\n\n";
                        }
                       
                        String imprimirPtds = ImprimirOperandos(operando);
                        finl += s + imprimirPtds;
                        finl += s + "--------------------------------------------------------------------------------------------------------------------------\n";
                        operando = null;
                        b1 = b2 = b3 = b4 = b5 = b6 = b7 = b8 = b9 = b10 = 0;
                        c1 = c2 = c3 = c4 = c5 = c6 = c7 = c8 = c9 = c10 = c11 = c12 = c13 = c14 = c15 = 0;
                    }
                }

            }
            if (banEnd) {
                finl += s + "Error: No se encontró el END.";
            }
            this.txtAreaResultado.setText(finl); //imprimet todo CREO!

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCargarArchivo;
    private javax.swing.JButton btnCargarCODLOC;
    private javax.swing.JButton btnCargarTABOP;
    private javax.swing.JButton btnMostrarArchivo;
    private javax.swing.JButton btnMostrarTABOP;
    public static javax.swing.JButton btnMostrarTABSIM;
    private javax.swing.JButton btnResultado;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTextArea txtAreaCargarArchivo;
    private javax.swing.JTextArea txtAreaCargarTABOP;
    private javax.swing.JTextArea txtAreaResultado;
    private javax.swing.JTextArea txtCODLOC;
    private javax.swing.JTextArea txtTABSIM;
    // End of variables declaration//GEN-END:variables
}
